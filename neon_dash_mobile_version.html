<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON DASH 1.9 - ANIMATED</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body { margin: 0; overflow: hidden; background: #000000; font-family: 'Orbitron', sans-serif; user-select: none; touch-action: none; }
    canvas { display: block; }
    
    .mobile-controls {
        position: absolute;
        bottom: 40px;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 30px;
        box-sizing: border-box;
        pointer-events: none;
        transition: opacity 0.4s ease;
    }
    
    .btn {
        width: 70px;
        height: 70px;
        border: 2px solid #ffffff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #ffffff;
        font-size: 24px;
        background: rgba(255, 255, 255, 0.05);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        pointer-events: auto;
        transition: transform 0.1s;
    }

    .btn-pause {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        box-shadow: none;
        position: relative;
    }
    
    .btn-pause::before, .btn-pause::after {
        content: '';
        position: absolute;
        width: 4px;
        height: 16px;
        background: white;
        border-radius: 2px;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        transition: all 0.2s ease;
    }
    .btn-pause::before { left: 14px; }
    .btn-pause::after { right: 14px; }
    
    .btn-pause.is-paused::before {
        height: 0; width: 0;
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-left: 18px solid white;
        background: transparent;
        box-shadow: none;
        left: 14px;
    }
    .btn-pause.is-paused::after { opacity: 0; transform: scale(0); }

    #home-btn {
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 35px;
        border: 2px solid #00ffff;
        background: rgba(0, 255, 255, 0.1);
        color: #00ffff;
        font-family: 'Orbitron', sans-serif;
        font-weight: 700;
        font-size: 14px;
        letter-spacing: 2px;
        border-radius: 4px;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        pointer-events: auto;
        z-index: 100;
        transition: opacity 0.3s;
    }
</style>
</head>
<body>

<div class="mobile-controls ui-hidden" id="ui-controls">
    <div class="btn" id="left-btn">◀</div>
    <div class="btn btn-pause" id="pause-btn"></div>
    <div class="btn" id="right-btn">▶</div>
</div>

<div id="home-btn" class="ui-hidden">HOME</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiLayer = document.getElementById("ui-controls");
const pauseBtn = document.getElementById("pause-btn");
const homeBtn = document.getElementById("home-btn");

let lanePositions = [];

const COLORS = {
    player: "#00ffff", 
    obstacle: "#ff0055", 
    zen: "#39ff14", 
    gold: "#FFD700",
    track: "rgba(0, 255, 255, 0.08)",
    overlay: "rgba(0, 0, 0, 0.85)"
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const center = canvas.width / 2;
    const spacing = Math.min(canvas.width / 3.2, 140);
    lanePositions = [center - spacing, center, center + spacing];
}
window.addEventListener("resize", resize);
resize();

let gameState = {
    started: false,
    paused: false,
    gameOver: false,
    showGameOverUI: false,
    uiTimer: 0, 
    deathTimer: 0,
    score: 0, 
    zenRunCount: 0, 
    totalZen: parseInt(localStorage.getItem('neonDashTotalZen')) || 0,
    highScore: parseInt(localStorage.getItem('neonDashHighScore')) || 0, 
    speed: 6.5,
    baseSpeed: 6.5,
    timeSinceLastSpawn: 0,
    fadeLevel: 0
};

const player = { 
    lane: 1, 
    x: 0, 
    targetX: 0, 
    y: 0, 
    w: 40, 
    h: 40, 
    groundY: 0,
    tilt: 0,
    lastX: 0,
    trail: []
};

let obstacles = [];
let zens = []; 
let particles = []; 

function initPlayer() {
    player.groundY = canvas.height - 160;
    player.y = player.groundY;
    player.lane = 1;
    player.targetX = lanePositions[1];
    player.x = lanePositions[1];
    player.lastX = player.x;
    player.tilt = 0;
    player.trail = [];
}
initPlayer();

function resetToHome() {
    gameState.started = false;
    gameState.paused = false;
    gameState.gameOver = false;
    gameState.showGameOverUI = false;
    uiLayer.classList.add('ui-hidden');
    homeBtn.classList.add('ui-hidden');
    pauseBtn.classList.remove('is-paused');
    obstacles = [];
    zens = [];
    particles = [];
}

function createExplosion(x, y, color, count, speed = 20) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y, 
            vx: (Math.random() - 0.5) * speed, 
            vy: (Math.random() - 0.5) * speed,
            life: 1.0, color: color, size: Math.random() * 5 + 2
        });
    }
}

function resetGame() {
    gameState.started = true; 
    gameState.paused = false;
    gameState.gameOver = false;
    gameState.showGameOverUI = false; 
    gameState.deathTimer = 0; 
    gameState.uiTimer = 0;
    gameState.score = 0; 
    gameState.zenRunCount = 0;
    gameState.speed = 6.5; 
    gameState.baseSpeed = 6.5;
    pauseBtn.classList.remove('is-paused');
    homeBtn.classList.add('ui-hidden');
    obstacles = []; 
    zens = [];
    particles = []; 
    initPlayer();
    uiLayer.classList.remove('ui-hidden');
}

function togglePause() {
    if (gameState.started && !gameState.gameOver) {
        gameState.paused = !gameState.paused;
        if (gameState.paused) {
            pauseBtn.classList.add('is-paused');
            homeBtn.classList.remove('ui-hidden');
            homeBtn.style.top = (canvas.height / 2 + 100) + "px"; 
        } else {
            pauseBtn.classList.remove('is-paused');
            homeBtn.classList.add('ui-hidden');
        }
    }
}

document.getElementById("left-btn").addEventListener("touchstart", (e) => { e.preventDefault(); if(!gameState.paused) moveLeft(); });
document.getElementById("right-btn").addEventListener("touchstart", (e) => { e.preventDefault(); if(!gameState.paused) moveRight(); });
document.getElementById("pause-btn").addEventListener("touchstart", (e) => { e.preventDefault(); togglePause(); });
homeBtn.addEventListener("touchstart", (e) => { e.preventDefault(); resetToHome(); });

function moveLeft() { if (player.lane > 0 && !gameState.gameOver) { player.lane--; player.targetX = lanePositions[player.lane]; } }
function moveRight() { if (player.lane < 2 && !gameState.gameOver) { player.lane++; player.targetX = lanePositions[player.lane]; } }

canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    if (!gameState.started) resetGame();
});

function drawPlayer(x, y, w, h, tilt, isTrail = false, alpha = 1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(tilt);
    
    // Motion Stretch
    const stretchY = 1 + Math.abs(tilt) * 0.5;
    const squeezeX = 1 - Math.abs(tilt) * 0.2;
    ctx.scale(squeezeX, stretchY);

    ctx.globalAlpha = alpha;
    ctx.shadowBlur = isTrail ? 5 : 25; 
    ctx.shadowColor = COLORS.player;
    ctx.fillStyle = COLORS.player;
    
    // Main Triangle Body
    ctx.beginPath();
    ctx.moveTo(0, -h);          
    ctx.lineTo(-w/2, 0);      
    ctx.lineTo(w/2, 0);      
    ctx.closePath(); 
    ctx.fill();

    if (!isTrail) {
        // Engine Core
        ctx.fillStyle = "#ffffff";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, -h/2, w/6 + Math.sin(Date.now()*0.02)*2, 0, Math.PI*2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawNeonShape(x, y, w, h, color, glow, type = 'rect') {
    ctx.save();
    ctx.shadowBlur = glow; 
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    if (type === 'zen') {
        ctx.beginPath();
        ctx.moveTo(x, y - h/2);
        ctx.lineTo(x + w/2, y);
        ctx.lineTo(x, y + h/2);
        ctx.lineTo(x - w/2, y);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#ffffff";
        ctx.beginPath(); ctx.arc(x, y, w/4, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillRect(x - w/2, y - h, w, h);
    }
    ctx.restore();
}

function drawText(text, size, color, xOffset, yOffset, glow = 0, scale = 1, align = "center") {
    ctx.save();
    ctx.translate(canvas.width/2 + xOffset, canvas.height/2 + yOffset);
    ctx.scale(scale, scale);
    ctx.shadowBlur = glow; ctx.shadowColor = color; ctx.fillStyle = color;
    ctx.font = `bold ${size}px Orbitron`; ctx.textAlign = align;
    ctx.fillText(text, 0, 0);
    ctx.restore();
}

function update() {
    if (!gameState.started || gameState.paused) return;

    // Particle logic
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx; particles[i].y += particles[i].vy;
        particles[i].life -= 0.025; if (particles[i].life <= 0) particles.splice(i, 1);
    }

    if (gameState.gameOver) {
        if (!uiLayer.classList.contains('ui-hidden')) uiLayer.classList.add('ui-hidden');
        gameState.deathTimer++;
        if (gameState.deathTimer > 45) {
            gameState.showGameOverUI = true;
            if (gameState.uiTimer < 1) gameState.uiTimer += 0.08;
            homeBtn.classList.remove('ui-hidden');
            homeBtn.style.top = (canvas.height / 2 + 60) + "px"; 
        }
        return;
    }

    gameState.score += 0.2; 
    gameState.baseSpeed += 0.0007; 
    gameState.speed = gameState.baseSpeed;

    // Movement & Animation Physics
    player.lastX = player.x;
    player.x += (player.targetX - player.x) * 0.18;
    
    // Velocity-based tilt (capped at 0.4 radians)
    const velocity = player.x - player.lastX;
    player.tilt = Math.max(-0.4, Math.min(0.4, velocity * 0.08));

    // Trail logic
    if (Math.abs(velocity) > 0.5) {
        player.trail.push({ x: player.x, y: player.y, tilt: player.tilt, life: 1.0 });
    }
    for (let i = player.trail.length - 1; i >= 0; i--) {
        player.trail[i].life -= 0.1;
        if (player.trail[i].life <= 0) player.trail.splice(i, 1);
    }

    // Engine exhaust particles
    if (Math.random() > 0.5) {
        particles.push({
            x: player.x + (Math.random()-0.5)*20,
            y: player.y,
            vx: (Math.random()-0.5)*2,
            vy: 2 + Math.random()*3,
            life: 0.5,
            color: COLORS.player,
            size: Math.random()*3
        });
    }

    // Spawning & Collision (Same as 1.8)
    gameState.timeSinceLastSpawn++;
    if (gameState.timeSinceLastSpawn > Math.max(18, 45 - gameState.baseSpeed)) {
        const obstacleLane = Math.floor(Math.random() * 3);
        obstacles.push({ x: lanePositions[obstacleLane], y: -100 });
        if (Math.random() > 0.4) {
            const zenLane = Math.floor(Math.random() * 3);
            zens.push({ x: lanePositions[zenLane], y: -100, collected: false });
        }
        gameState.timeSinceLastSpawn = 0;
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.y += gameState.speed;
        if (Math.abs(player.x - o.x) < 30 && Math.abs((player.y - 20) - o.y) < 30) {
            gameState.gameOver = true;
            createExplosion(player.x, player.y - 20, COLORS.player, 35);
            if (Math.floor(gameState.score) > gameState.highScore) {
                gameState.highScore = Math.floor(gameState.score);
                localStorage.setItem('neonDashHighScore', gameState.highScore);
            }
        } else if (o.y > canvas.height + 100) obstacles.splice(i, 1);
    }

    for (let i = zens.length - 1; i >= 0; i--) {
        let z = zens[i];
        z.y += gameState.speed;
        if (!z.collected && Math.abs(player.x - z.x) < 35 && Math.abs((player.y - 20) - z.y) < 35) {
            z.collected = true;
            gameState.zenRunCount++;
            gameState.totalZen++;
            localStorage.setItem('neonDashTotalZen', gameState.totalZen); 
            createExplosion(z.x, z.y, COLORS.zen, 15, 12);
            zens.splice(i, 1);
        } else if (z.y > canvas.height + 100) zens.splice(i, 1);
    }
}

function loop() {
    ctx.fillStyle = "#000000"; ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState.started) {
        ctx.strokeStyle = COLORS.track; ctx.lineWidth = 3;
        lanePositions.forEach(x => { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); });
        
        // Draw Trail After-images
        player.trail.forEach(t => drawPlayer(t.x, t.y, 40, 40, t.tilt, true, t.life * 0.4));

        zens.forEach(z => drawNeonShape(z.x, z.y, 22, 22, COLORS.zen, 20, 'zen'));
        if (!gameState.gameOver) drawPlayer(player.x, player.y, 40, 40, player.tilt);
        obstacles.forEach(o => drawNeonShape(o.x, o.y, 45, 45, COLORS.obstacle, 25, 'rect'));
        
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }

    // UI Rendering
    if (!gameState.started) {
        drawText("NEON DASH", 42, COLORS.player, 0, -40, 30);
        drawText("TAP TO START", 15, "#fff", 0, 10);
        const zenX = canvas.width - 65;
        const zenY = 45;
        drawNeonShape(zenX, zenY, 22, 22, COLORS.zen, 20, 'zen');
        ctx.font = "bold 20px Orbitron";
        ctx.fillStyle = COLORS.zen;
        ctx.textAlign = "left";
        ctx.fillText(`${gameState.totalZen}`, zenX + 17, zenY + 8);

    } else if (gameState.paused) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        drawText("PAUSED", 48, "#fff", 0, -60, 20); 
        drawText(`SCORE : ${Math.floor(gameState.score)}`, 22, "#ffffff", 0, 0, 15); 
        drawText(`ZEN : ${gameState.zenRunCount}`, 18, COLORS.zen, 0, 40, 10);

    } else if (gameState.showGameOverUI) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        drawText("CRASHED", 48, COLORS.obstacle, 0, -100, 35);
        drawText(`SCORE : ${Math.floor(gameState.score)}`, 22, "#ffffff", 0, -50);
        drawText(`BEST : ${gameState.highScore}`, 18, COLORS.gold, 0, 0, 15); 

    } else if (gameState.started) {
        ctx.font = "bold 16px Orbitron"; 
        ctx.textAlign = "left";
        ctx.fillStyle = COLORS.zen; 
        ctx.fillText(`ZEN : ${gameState.zenRunCount}`, 25, 45);
        ctx.fillStyle = COLORS.player;
        ctx.fillText(`SCORE : ${Math.floor(gameState.score)}`, 25, 75);
        ctx.textAlign = "right"; 
        ctx.fillStyle = COLORS.gold; 
        ctx.fillText(`BEST : ${gameState.highScore}`, canvas.width - 25, 45);
    }
    
    update();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
