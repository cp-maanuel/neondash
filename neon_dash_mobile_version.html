<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON DASH 0.1 - OVERDRIVE BLOOM</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body { margin: 0; overflow: hidden; background: #010101; font-family: 'Orbitron', sans-serif; user-select: none; touch-action: none; }
    canvas { display: block; }
    
    .mobile-controls {
        position: absolute;
        bottom: 40px;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 30px;
        box-sizing: border-box;
        pointer-events: none;
        transition: opacity 0.4s ease;
    }
    
    .btn {
        width: 70px;
        height: 70px;
        border: 2px solid #ffffff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #ffffff;
        font-size: 24px;
        background: rgba(255, 255, 255, 0.05);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        pointer-events: auto;
        transition: transform 0.1s;
    }

    .btn-pause {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        box-shadow: none;
        position: relative;
    }
    .btn-pause::before, .btn-pause::after {
        content: '';
        position: absolute;
        width: 4px;
        height: 16px;
        background: white;
        border-radius: 2px;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }
    .btn-pause::before { left: 14px; }
    .btn-pause::after { right: 14px; }
    
    .btn:active { transform: scale(0.85); background: rgba(255, 255, 255, 0.3); }
    .ui-hidden { opacity: 0; pointer-events: none; }
</style>
</head>
<body>

<div class="mobile-controls ui-hidden" id="ui-controls">
    <div class="btn" id="left-btn">◀</div>
    <div class="btn btn-pause" id="pause-btn"></div>
    <div class="btn" id="right-btn">▶</div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiLayer = document.getElementById("ui-controls");
let lanePositions = [];

const COLORS = {
    player: "#00ffff", 
    obstacle: "#ff0055", 
    track: "rgba(0, 255, 255, 0.1)",
    gold: "#FFD700",
    overlay: "rgba(0, 0, 0, 0.85)"
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const center = canvas.width / 2;
    const spacing = Math.min(canvas.width / 3.5, 130);
    lanePositions = [center - spacing, center, center + spacing];
}
window.addEventListener("resize", resize);
resize();

let gameState = {
    started: false,
    paused: false,
    gameOver: false,
    showGameOverUI: false,
    uiTimer: 0, 
    deathTimer: 0,
    score: 0,
    level: 1,
    highScore: parseInt(localStorage.getItem('neonDashHigh')) || 0,
    speed: 7,
    baseSpeed: 7,
    timeSinceLastSpawn: 0,
    laneStreaks: [0, 0, 0] // Track consecutive obstacles per lane
};

const player = { lane: 1, x: 0, targetX: 0, y: 0, w: 40, h: 40, vy: 0, groundY: 0, isJumping: false };
let obstacles = [];
let particles = []; 
let dustTrail = [];

function initPlayer() {
    player.groundY = canvas.height - 160;
    player.y = player.groundY;
    player.lane = 1;
    player.targetX = lanePositions[1];
    player.x = lanePositions[1];
    player.vy = 0;
}
initPlayer();

function resetToHome() {
    gameState.started = false;
    gameState.paused = false;
    gameState.gameOver = false;
    gameState.showGameOverUI = false;
    uiLayer.classList.add('ui-hidden');
    obstacles = [];
    particles = [];
    dustTrail = [];
}

function resetGame() {
    gameState.started = true; 
    gameState.paused = false;
    gameState.gameOver = false;
    gameState.showGameOverUI = false; 
    gameState.deathTimer = 0; 
    gameState.uiTimer = 0;
    gameState.score = 0; 
    gameState.level = 1;
    gameState.speed = 7; 
    gameState.baseSpeed = 7;
    gameState.laneStreaks = [0, 0, 0];
    obstacles = []; 
    particles = []; 
    dustTrail = [];
    initPlayer();
    uiLayer.classList.remove('ui-hidden');
}

function drawHomeSymbol(x, y, size) {
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y - size/2);
    ctx.lineTo(x - size/2, y);
    ctx.lineTo(x - size/2, y + size/2);
    ctx.lineTo(x + size/2, y + size/2);
    ctx.lineTo(x + size/2, y);
    ctx.closePath();
    ctx.stroke();
}

function drawPlaySymbol(x, y, size) {
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.moveTo(x - size/3, y - size/2);
    ctx.lineTo(x + size/2, y);
    ctx.lineTo(x - size/3, y + size/2);
    ctx.closePath();
    ctx.fill();
}

function drawRetrySymbol(x, y, size) {
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, size/2, 0, Math.PI * 1.5);
    ctx.stroke();
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.moveTo(x, y - size/2 - 5);
    ctx.lineTo(x + 8, y - size/2);
    ctx.lineTo(x, y - size/2 + 5);
    ctx.fill();
}

/* ============ INPUT ============ */
document.getElementById("left-btn").addEventListener("touchstart", (e) => { e.preventDefault(); if(!gameState.paused) moveLeft(); });
document.getElementById("right-btn").addEventListener("touchstart", (e) => { e.preventDefault(); if(!gameState.paused) moveRight(); });
document.getElementById("pause-btn").addEventListener("touchstart", (e) => { e.preventDefault(); gameState.paused = !gameState.paused; });

function moveLeft() { if (player.lane > 0 && !gameState.gameOver) { player.lane--; player.targetX = lanePositions[player.lane]; } }
function moveRight() { if (player.lane < 2 && !gameState.gameOver) { player.lane++; player.targetX = lanePositions[player.lane]; } }
function jump() { if (!player.isJumping && !gameState.gameOver) { player.vy = -18; player.isJumping = true; } }

canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const tx = e.touches[0].clientX;
    const ty = e.touches[0].clientY;
    const midX = canvas.width / 2;
    const midY = canvas.height / 2;

    if (!gameState.started) {
        resetGame();
    } else if (gameState.paused) {
        if (tx < midX && ty > midY + 40) gameState.paused = false;
        if (tx > midX && ty > midY + 40) resetToHome();
    } else if (gameState.showGameOverUI) {
        if (tx < midX && ty > midY + 40) resetGame();
        if (tx > midX && ty > midY + 40) resetToHome();
    } else if (!gameState.gameOver) {
        if (ty < canvas.height - 150) jump();
    }
});

function update() {
    if (!gameState.started || gameState.paused) return;

    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life -= 0.02;
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    if (gameState.gameOver) {
        if (!uiLayer.classList.contains('ui-hidden')) uiLayer.classList.add('ui-hidden');
        gameState.deathTimer++;
        if (gameState.deathTimer > 40) {
            gameState.showGameOverUI = true;
            if (gameState.uiTimer < 1) gameState.uiTimer += 0.07;
        }
        return;
    }

    gameState.score += 0.25;
    // Calculate Level
    gameState.level = Math.floor(gameState.score / 1000) + 1;
    
    gameState.baseSpeed += 0.0012; 
    gameState.speed = gameState.baseSpeed;

    player.x += (player.targetX - player.x) * 0.25; 
    player.vy += 0.95; 
    player.y += player.vy;
    if (player.y > player.groundY) { player.y = player.groundY; player.vy = 0; player.isJumping = false; }

    gameState.timeSinceLastSpawn++;
    
    if (gameState.timeSinceLastSpawn > Math.max(10, 32 - gameState.baseSpeed)) {
        // Find safe lanes (Lanes that MUST be safe because they've had 3 obstacles in a row)
        let forcedSafeLanes = [];
        gameState.laneStreaks.forEach((streak, idx) => {
            if (streak >= 3) forcedSafeLanes.push(idx);
        });

        let safeLane;
        if (forcedSafeLanes.length > 0) {
            // Pick one of the lanes that HAS to be safe
            safeLane = forcedSafeLanes[Math.floor(Math.random() * forcedSafeLanes.length)];
        } else {
            // Otherwise pick any random lane to be safe
            safeLane = Math.floor(Math.random() * 3);
        }

        // Spawn obstacles in non-safe lanes
        [0, 1, 2].forEach(l => { 
            if (l !== safeLane) {
                obstacles.push({ x: lanePositions[l], y: -100 }); 
                gameState.laneStreaks[l]++; // Increment streak
            } else {
                gameState.laneStreaks[l] = 0; // Reset safe lane streak
            }
        });
        
        gameState.timeSinceLastSpawn = 0;
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.y += gameState.speed;
        if (Math.abs(player.x - o.x) < 35 && Math.abs((player.y - 20) - o.y) < 35) {
            gameState.gameOver = true;
            for(let k=0; k<40; k++) particles.push({x:player.x, y:player.y-20, vx:(Math.random()-0.5)*18, vy:(Math.random()-0.5)*18, life:1.0, color:COLORS.player, size:Math.random()*6+3});
            if (gameState.score > gameState.highScore) {
                gameState.highScore = Math.floor(gameState.score);
                localStorage.setItem('neonDashHigh', gameState.highScore);
            }
        } else if (o.y > canvas.height + 100) obstacles.splice(i, 1);
    }
}

function loop() {
    ctx.fillStyle = "#010101";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState.started) {
        ctx.strokeStyle = COLORS.track;
        ctx.lineWidth = 2;
        lanePositions.forEach(x => { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); });

        if (!gameState.gameOver) {
            ctx.shadowBlur = 35; ctx.shadowColor = COLORS.player;
            ctx.fillStyle = COLORS.player;
            ctx.fillRect(player.x - 20, player.y - 40, 40, 40);
        }
        obstacles.forEach(o => {
            ctx.shadowBlur = 20; ctx.shadowColor = COLORS.obstacle;
            ctx.fillStyle = COLORS.obstacle;
            ctx.fillRect(o.x - 22.5, o.y - 45, 45, 45);
        });
        ctx.shadowBlur = 0;
    }

    particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;

    if (!gameState.started) {
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = COLORS.player; ctx.font = "bold 42px Orbitron"; ctx.textAlign="center";
        ctx.fillText("NEON DASH", canvas.width/2, canvas.height/2 - 20);
        ctx.fillStyle = "#fff"; ctx.font = "15px Orbitron";
        ctx.fillText("TAP TO START", canvas.width/2, canvas.height/2 + 30);
    } else if (gameState.paused) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "#fff"; ctx.font = "bold 48px Orbitron"; ctx.textAlign="center";
        ctx.fillText("PAUSED", canvas.width/2, canvas.height/2 - 60);
        drawPlaySymbol(canvas.width/2 - 50, canvas.height/2 + 80, 30);
        drawHomeSymbol(canvas.width/2 + 50, canvas.height/2 + 80, 30);
    } else if (gameState.showGameOverUI) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        const pop = 1.0 + Math.sin(gameState.uiTimer * Math.PI) * 0.1; 
        ctx.save(); ctx.translate(canvas.width/2, canvas.height/2 - 60); ctx.scale(pop, pop);
        ctx.fillStyle = COLORS.obstacle; ctx.font = "bold 48px Orbitron"; ctx.textAlign="center";
        ctx.fillText("CRASHED", 0, 0); ctx.restore();
        
        ctx.fillStyle = "#fff"; ctx.font = "22px Orbitron"; ctx.textAlign="center";
        ctx.fillText(`SCORE: ${Math.floor(gameState.score)}`, canvas.width/2, canvas.height/2 - 10);
        ctx.fillStyle = COLORS.gold; ctx.font = "18px Orbitron";
        ctx.fillText(`BEST: ${gameState.highScore}`, canvas.width/2, canvas.height/2 + 25);
        
        drawRetrySymbol(canvas.width/2 - 50, canvas.height/2 + 80, 30);
        drawHomeSymbol(canvas.width/2 + 50, canvas.height/2 + 80, 30);
    } else {
        // In-game HUD
        ctx.fillStyle = "#fff"; ctx.font = "bold 16px Orbitron"; ctx.textAlign = "left";
        ctx.fillText(`SCORE: ${Math.floor(gameState.score)}`, 25, 45);
        
        // Golden Level Text
        ctx.shadowBlur = 15; ctx.shadowColor = COLORS.gold;
        ctx.fillStyle = COLORS.gold; ctx.textAlign = "center";
        ctx.font = "bold 20px Orbitron";
        ctx.fillText(`LEVEL ${gameState.level}`, canvas.width/2, 45);
        ctx.shadowBlur = 0;

        ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.font = "bold 14px Orbitron"; ctx.textAlign = "right";
        ctx.fillText(`BEST: ${gameState.highScore}`, canvas.width - 25, 45);
    }

    update();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
